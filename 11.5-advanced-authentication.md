# Chapter 11.5: Advanced Authentication & Security

## 🎯 Learning Objectives

By the end of this chapter, you will:

- Implement Two-Factor Authentication (2FA/MFA)
- Set up OAuth2 social authentication (Google, GitHub)
- Implement session management
- Add audit logging for security
- Set up account security features
- Implement API key authentication

## 📚 Prerequisites

Complete [Chapter 11: Authentication & Authorization](11-authentication.md) before starting this chapter.

## 🔄 Laravel vs FastAPI Advanced Auth

| Feature            | Laravel                | FastAPI                       |
| ------------------ | ---------------------- | ----------------------------- |
| 2FA                | Laravel Fortify        | pyotp + QR codes              |
| Social Auth        | Laravel Socialite      | authlib                       |
| Session Management | Session middleware     | Redis + custom implementation |
| Audit Logging      | Activity logs packages | Custom logging + DB           |
| API Keys           | Sanctum tokens         | Custom API key system         |
| Device Management  | Laravel Jetstream      | Custom implementation         |

## 📚 Core Concepts

### 1. Two-Factor Authentication (2FA)

```python
# Install dependencies
# pip install pyotp qrcode Pillow

import pyotp
import qrcode
from io import BytesIO
import base64
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey
from pydantic import BaseModel

# app/models/user.py
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)

    # 2FA fields
    two_factor_secret = Column(String, nullable=True)
    two_factor_enabled = Column(Boolean, default=False)
    two_factor_backup_codes = Column(String, nullable=True)  # JSON array

# app/schemas/auth.py
class TwoFactorSetup(BaseModel):
    qr_code: str
    secret: str
    backup_codes: list[str]

class TwoFactorVerify(BaseModel):
    code: str

class LoginWithTwoFactor(BaseModel):
    email: EmailStr
    password: str
    two_factor_code: str | None = None

# app/api/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import StreamingResponse
import json

router = APIRouter()

def generate_backup_codes(count: int = 8) -> list[str]:
    """Generate backup codes for 2FA recovery"""
    import secrets
    return [secrets.token_hex(4).upper() for _ in range(count)]

@router.post("/2fa/setup", response_model=TwoFactorSetup)
async def setup_two_factor(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Setup 2FA for user account

    CONCEPT: Time-based One-Time Password (TOTP)
    - Generates secret key
    - Creates QR code for authenticator app
    - Provides backup codes
    - Like Laravel Fortify's 2FA setup
    """
    if current_user.two_factor_enabled:
        raise HTTPException(400, "2FA already enabled")

    # Generate secret
    secret = pyotp.random_base32()

    # Create TOTP URI for QR code
    totp = pyotp.TOTP(secret)
    uri = totp.provisioning_uri(
        name=current_user.email,
        issuer_name="Your App Name"
    )

    # Generate QR code
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(uri)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")
    buffer = BytesIO()
    img.save(buffer, format='PNG')
    qr_code = base64.b64encode(buffer.getvalue()).decode()

    # Generate backup codes
    backup_codes = generate_backup_codes()

    # Store secret (not enabled yet)
    current_user.two_factor_secret = secret
    current_user.two_factor_backup_codes = json.dumps(backup_codes)
    await db.commit()

    return TwoFactorSetup(
        qr_code=f"data:image/png;base64,{qr_code}",
        secret=secret,
        backup_codes=backup_codes
    )

@router.post("/2fa/verify")
async def verify_two_factor_setup(
    data: TwoFactorVerify,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Verify 2FA code and enable 2FA

    CONCEPT: Code Verification
    - Validates TOTP code
    - Enables 2FA if valid
    - Like Laravel Fortify's confirm
    """
    if not current_user.two_factor_secret:
        raise HTTPException(400, "2FA not set up")

    totp = pyotp.TOTP(current_user.two_factor_secret)

    if not totp.verify(data.code, valid_window=1):
        raise HTTPException(400, "Invalid code")

    # Enable 2FA
    current_user.two_factor_enabled = True
    await db.commit()

    return {"message": "2FA enabled successfully"}

@router.post("/2fa/disable")
async def disable_two_factor(
    data: TwoFactorVerify,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Disable 2FA (requires code verification)"""
    if not current_user.two_factor_enabled:
        raise HTTPException(400, "2FA not enabled")

    totp = pyotp.TOTP(current_user.two_factor_secret)

    if not totp.verify(data.code, valid_window=1):
        raise HTTPException(400, "Invalid code")

    # Disable 2FA
    current_user.two_factor_enabled = False
    current_user.two_factor_secret = None
    current_user.two_factor_backup_codes = None
    await db.commit()

    return {"message": "2FA disabled"}

@router.post("/login-with-2fa", response_model=Token)
async def login_with_two_factor(
    data: LoginWithTwoFactor,
    db: AsyncSession = Depends(get_db)
):
    """
    Login with 2FA support

    CONCEPT: Two-Step Login
    - First validates password
    - Then validates 2FA code if enabled
    - Returns token only if both valid
    """
    # Find user
    result = await db.execute(select(User).where(User.email == data.email))
    user = result.scalar_one_or_none()

    if not user or not verify_password(data.password, user.hashed_password):
        raise HTTPException(401, "Invalid credentials")

    # Check if 2FA is enabled
    if user.two_factor_enabled:
        if not data.two_factor_code:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="2FA code required"
            )

        # Verify 2FA code
        totp = pyotp.TOTP(user.two_factor_secret)

        # Check TOTP code or backup code
        valid_code = totp.verify(data.two_factor_code, valid_window=1)

        if not valid_code:
            # Check backup codes
            backup_codes = json.loads(user.two_factor_backup_codes or "[]")
            if data.two_factor_code.upper() in backup_codes:
                # Remove used backup code
                backup_codes.remove(data.two_factor_code.upper())
                user.two_factor_backup_codes = json.dumps(backup_codes)
                await db.commit()
                valid_code = True

        if not valid_code:
            raise HTTPException(401, "Invalid 2FA code")

    # Create token
    access_token = create_access_token(data={"sub": user.email})

    return {"access_token": access_token, "token_type": "bearer"}
```

### 2. OAuth2 Social Authentication

```python
# Install authlib
# pip install authlib httpx

from authlib.integrations.starlette_client import OAuth
from starlette.config import Config
from fastapi import Request
from fastapi.responses import RedirectResponse

# app/core/config.py
class Settings(BaseSettings):
    # OAuth2 providers
    GOOGLE_CLIENT_ID: str | None = None
    GOOGLE_CLIENT_SECRET: str | None = None
    GITHUB_CLIENT_ID: str | None = None
    GITHUB_CLIENT_SECRET: str | None = None

    # OAuth2 redirect URLs
    GOOGLE_REDIRECT_URI: str = "http://localhost:8000/auth/google/callback"
    GITHUB_REDIRECT_URI: str = "http://localhost:8000/auth/github/callback"

# app/core/oauth.py
config = Config('.env')
oauth = OAuth(config)

# Configure Google
oauth.register(
    name='google',
    client_id=settings.GOOGLE_CLIENT_ID,
    client_secret=settings.GOOGLE_CLIENT_SECRET,
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={
        'scope': 'openid email profile'
    }
)

# Configure GitHub
oauth.register(
    name='github',
    client_id=settings.GITHUB_CLIENT_ID,
    client_secret=settings.GITHUB_CLIENT_SECRET,
    authorize_url='https://github.com/login/oauth/authorize',
    authorize_params=None,
    access_token_url='https://github.com/login/oauth/access_token',
    access_token_params=None,
    client_kwargs={'scope': 'user:email'},
)

# app/models/user.py
class SocialAccount(Base):
    """
    CONCEPT: Social Account Linking
    - Links OAuth accounts to users
    - Like Laravel Socialite
    """
    __tablename__ = "social_accounts"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    provider = Column(String, nullable=False)  # google, github, etc.
    provider_user_id = Column(String, nullable=False)
    access_token = Column(String, nullable=True)
    refresh_token = Column(String, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    user = relationship("User", backref="social_accounts")

# app/api/endpoints/auth.py
@router.get("/auth/google")
async def google_login(request: Request):
    """
    Initiate Google OAuth2 login

    CONCEPT: OAuth2 Authorization Code Flow
    - Redirects to Google login
    - Like Laravel Socialite's redirect()
    """
    redirect_uri = settings.GOOGLE_REDIRECT_URI
    return await oauth.google.authorize_redirect(request, redirect_uri)

@router.get("/auth/google/callback")
async def google_callback(
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """
    Handle Google OAuth2 callback

    CONCEPT: OAuth2 Token Exchange
    - Exchanges code for token
    - Gets user info
    - Creates or links account
    - Like Laravel Socialite's user()
    """
    try:
        token = await oauth.google.authorize_access_token(request)
    except Exception as e:
        raise HTTPException(400, f"OAuth error: {str(e)}")

    # Get user info from Google
    user_info = token.get('userinfo')
    if not user_info:
        raise HTTPException(400, "Failed to get user info")

    email = user_info.get('email')
    google_id = user_info.get('sub')
    name = user_info.get('name')

    # Find or create user
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()

    if not user:
        # Create new user
        user = User(
            email=email,
            full_name=name,
            hashed_password=get_password_hash(secrets.token_urlsafe(32)),  # Random password
            is_active=True
        )
        db.add(user)
        await db.commit()
        await db.refresh(user)

    # Link or update social account
    result = await db.execute(
        select(SocialAccount).where(
            SocialAccount.user_id == user.id,
            SocialAccount.provider == "google"
        )
    )
    social_account = result.scalar_one_or_none()

    if not social_account:
        social_account = SocialAccount(
            user_id=user.id,
            provider="google",
            provider_user_id=google_id,
            access_token=token.get('access_token'),
            refresh_token=token.get('refresh_token')
        )
        db.add(social_account)
    else:
        social_account.access_token = token.get('access_token')
        social_account.refresh_token = token.get('refresh_token')

    await db.commit()

    # Create app access token
    access_token = create_access_token(data={"sub": user.email})

    # Redirect to frontend with token
    return RedirectResponse(
        url=f"{settings.FRONTEND_URL}/auth/callback?token={access_token}"
    )

@router.get("/auth/github")
async def github_login(request: Request):
    """Initiate GitHub OAuth2 login"""
    redirect_uri = settings.GITHUB_REDIRECT_URI
    return await oauth.github.authorize_redirect(request, redirect_uri)

@router.get("/auth/github/callback")
async def github_callback(
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """Handle GitHub OAuth2 callback"""
    # Similar to Google callback
    # Implementation follows same pattern
    pass
```

### 3. Session Management & Device Tracking

```python
# app/models/user.py
class Session(Base):
    """
    CONCEPT: Session Management
    - Track active sessions
    - Manage devices
    - Enable remote logout
    - Like Laravel's session management
    """
    __tablename__ = "sessions"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    token_id = Column(String, unique=True)  # JWT jti claim
    device_name = Column(String, nullable=True)
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    last_activity = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    user = relationship("User", backref="sessions")

# app/core/security.py
import uuid

def create_access_token_with_session(data: dict, expires_delta: timedelta = None):
    """Create token with session tracking"""
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)

    # Add unique session ID
    session_id = str(uuid.uuid4())
    to_encode.update({
        "exp": expire,
        "jti": session_id  # JWT ID for session tracking
    })

    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

    return encoded_jwt, session_id

# app/api/endpoints/auth.py
@router.post("/login-with-device", response_model=Token)
async def login_with_device(
    request: Request,
    form_data: OAuth2PasswordRequestForm = Depends(),
    device_name: str | None = None,
    db: AsyncSession = Depends(get_db)
):
    """
    Login with device tracking

    CONCEPT: Device Management
    - Creates session record
    - Tracks device info
    - Like Laravel Sanctum's token names
    """
    # Authenticate user
    result = await db.execute(select(User).where(User.email == form_data.username))
    user = result.scalar_one_or_none()

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(401, "Invalid credentials")

    # Create token with session ID
    access_token, session_id = create_access_token_with_session(
        data={"sub": user.email},
        expires_delta=timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    # Create session record
    session = Session(
        user_id=user.id,
        token_id=session_id,
        device_name=device_name or "Unknown Device",
        ip_address=request.client.host,
        user_agent=request.headers.get("user-agent", "Unknown")
    )
    db.add(session)
    await db.commit()

    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/sessions")
async def list_sessions(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    List all active sessions

    CONCEPT: Session Visibility
    - Shows active devices
    - Like Laravel's active sessions
    """
    result = await db.execute(
        select(Session).where(Session.user_id == current_user.id)
        .order_by(Session.last_activity.desc())
    )
    sessions = result.scalars().all()

    return [{
        "id": s.id,
        "device_name": s.device_name,
        "ip_address": s.ip_address,
        "last_activity": s.last_activity,
        "is_current": False  # TODO: compare with current session
    } for s in sessions]

@router.delete("/sessions/{session_id}")
async def revoke_session(
    session_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Revoke a specific session

    CONCEPT: Remote Logout
    - Deletes session
    - Blacklists token
    - Like Laravel's logout other devices
    """
    result = await db.execute(
        select(Session).where(
            Session.id == session_id,
            Session.user_id == current_user.id
        )
    )
    session = result.scalar_one_or_none()

    if not session:
        raise HTTPException(404, "Session not found")

    # Blacklist the token
    # (Implementation depends on your blacklist system)

    # Delete session
    await db.delete(session)
    await db.commit()

    return {"message": "Session revoked"}
```

### 4. Audit Logging

```python
# app/models/audit.py
class AuditLog(Base):
    """
    CONCEPT: Security Audit Trail
    - Tracks security events
    - Monitors suspicious activity
    - Like Laravel's activity logs
    """
    __tablename__ = "audit_logs"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    event_type = Column(String, nullable=False)  # login, logout, password_change, etc.
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    metadata = Column(String, nullable=True)  # JSON data
    success = Column(Boolean, default=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

# app/core/audit.py
async def log_audit_event(
    db: AsyncSession,
    event_type: str,
    user_id: int | None = None,
    ip_address: str | None = None,
    user_agent: str | None = None,
    metadata: dict | None = None,
    success: bool = True
):
    """Log security audit event"""
    log = AuditLog(
        user_id=user_id,
        event_type=event_type,
        ip_address=ip_address,
        user_agent=user_agent,
        metadata=json.dumps(metadata) if metadata else None,
        success=success
    )
    db.add(log)
    await db.commit()

# app/api/endpoints/auth.py
@router.post("/login")
async def login(
    request: Request,
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """Login with audit logging"""
    # Find user
    result = await db.execute(select(User).where(User.email == form_data.username))
    user = result.scalar_one_or_none()

    success = False
    user_id = None

    if user and verify_password(form_data.password, user.hashed_password):
        success = True
        user_id = user.id
        access_token = create_access_token(data={"sub": user.email})

    # Log audit event
    await log_audit_event(
        db=db,
        event_type="login",
        user_id=user_id,
        ip_address=request.client.host,
        user_agent=request.headers.get("user-agent"),
        metadata={"email": form_data.username},
        success=success
    )

    if not success:
        raise HTTPException(401, "Invalid credentials")

    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/audit-logs")
async def get_audit_logs(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db),
    limit: int = 50
):
    """Get user's audit logs"""
    result = await db.execute(
        select(AuditLog)
        .where(AuditLog.user_id == current_user.id)
        .order_by(AuditLog.created_at.desc())
        .limit(limit)
    )
    logs = result.scalars().all()

    return [{
        "event_type": log.event_type,
        "ip_address": log.ip_address,
        "success": log.success,
        "created_at": log.created_at
    } for log in logs]
```

### 5. API Key Authentication

```python
# app/models/api_key.py
class APIKey(Base):
    """
    CONCEPT: API Key Authentication
    - Alternative to JWT for services
    - Long-lived tokens
    - Scoped permissions
    - Like Laravel Sanctum's API tokens
    """
    __tablename__ = "api_keys"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    name = Column(String, nullable=False)
    key_hash = Column(String, unique=True, nullable=False)
    key_prefix = Column(String, nullable=False)  # First 8 chars for display
    scopes = Column(String, nullable=True)  # JSON array
    last_used_at = Column(DateTime, nullable=True)
    expires_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    user = relationship("User", backref="api_keys")

# app/core/security.py
import hashlib

def generate_api_key() -> tuple[str, str, str]:
    """
    Generate API key
    Returns: (full_key, key_hash, key_prefix)
    """
    # Generate random key
    full_key = f"sk_{secrets.token_urlsafe(32)}"

    # Hash for storage
    key_hash = hashlib.sha256(full_key.encode()).hexdigest()

    # Prefix for display
    key_prefix = full_key[:12]

    return full_key, key_hash, key_prefix

# app/api/endpoints/api_keys.py
from fastapi import Header

@router.post("/api-keys")
async def create_api_key(
    name: str,
    scopes: list[str] | None = None,
    expires_days: int | None = None,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Create new API key

    CONCEPT: API Key Generation
    - Creates long-lived token
    - Returns only once
    - Like Laravel Sanctum's createToken()
    """
    full_key, key_hash, key_prefix = generate_api_key()

    expires_at = None
    if expires_days:
        expires_at = datetime.now(timezone.utc) + timedelta(days=expires_days)

    api_key = APIKey(
        user_id=current_user.id,
        name=name,
        key_hash=key_hash,
        key_prefix=key_prefix,
        scopes=json.dumps(scopes) if scopes else None,
        expires_at=expires_at
    )
    db.add(api_key)
    await db.commit()

    return {
        "api_key": full_key,  # Only returned once!
        "key_prefix": key_prefix,
        "message": "Save this key - it won't be shown again"
    }

@router.get("/api-keys")
async def list_api_keys(
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """List user's API keys"""
    result = await db.execute(
        select(APIKey).where(APIKey.user_id == current_user.id)
    )
    keys = result.scalars().all()

    return [{
        "id": k.id,
        "name": k.name,
        "key_prefix": k.key_prefix,
        "last_used_at": k.last_used_at,
        "expires_at": k.expires_at
    } for k in keys]

@router.delete("/api-keys/{key_id}")
async def revoke_api_key(
    key_id: int,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
):
    """Revoke API key"""
    result = await db.execute(
        select(APIKey).where(
            APIKey.id == key_id,
            APIKey.user_id == current_user.id
        )
    )
    api_key = result.scalar_one_or_none()

    if not api_key:
        raise HTTPException(404, "API key not found")

    await db.delete(api_key)
    await db.commit()

    return {"message": "API key revoked"}

# Authentication dependency
async def get_user_from_api_key(
    x_api_key: str = Header(...),
    db: AsyncSession = Depends(get_db)
) -> User:
    """
    Authenticate using API key

    CONCEPT: API Key Authentication
    - Validates API key
    - Checks expiration
    - Updates last used
    - Like Laravel's Sanctum guard
    """
    # Hash the provided key
    key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()

    # Find API key
    result = await db.execute(
        select(APIKey).where(APIKey.key_hash == key_hash)
    )
    api_key = result.scalar_one_or_none()

    if not api_key:
        raise HTTPException(401, "Invalid API key")

    # Check expiration
    if api_key.expires_at and api_key.expires_at < datetime.now(timezone.utc):
        raise HTTPException(401, "API key expired")

    # Update last used
    api_key.last_used_at = datetime.now(timezone.utc)
    await db.commit()

    # Get user
    result = await db.execute(select(User).where(User.id == api_key.user_id))
    user = result.scalar_one()

    return user

# Usage in endpoints
@router.get("/api/data")
async def get_data(
    user: User = Depends(get_user_from_api_key),
    db: AsyncSession = Depends(get_db)
):
    """Protected endpoint using API key authentication"""
    return {"message": "API key authenticated", "user": user.email}
```

## 🔒 Advanced Security Patterns

### Account Lockout After Failed Attempts

```python
# app/models/user.py
class User(Base):
    __tablename__ = "users"

    # ... existing fields ...
    failed_login_attempts = Column(Integer, default=0)
    locked_until = Column(DateTime, nullable=True)

# app/api/endpoints/auth.py
@router.post("/login")
async def login_with_lockout(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """Login with account lockout protection"""
    result = await db.execute(select(User).where(User.email == form_data.username))
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(401, "Invalid credentials")

    # Check if account is locked
    if user.locked_until and user.locked_until > datetime.now(timezone.utc):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Account locked. Try again after {user.locked_until}"
        )

    # Verify password
    if not verify_password(form_data.password, user.hashed_password):
        # Increment failed attempts
        user.failed_login_attempts += 1

        # Lock account after 5 failed attempts
        if user.failed_login_attempts >= 5:
            user.locked_until = datetime.now(timezone.utc) + timedelta(minutes=30)

        await db.commit()
        raise HTTPException(401, "Invalid credentials")

    # Reset failed attempts on successful login
    user.failed_login_attempts = 0
    user.locked_until = None
    await db.commit()

    # Create token
    access_token = create_access_token(data={"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}
```

### Passwordless Authentication (Magic Links)

```python
# app/models/magic_link.py
class MagicLink(Base):
    """
    CONCEPT: Passwordless Login
    - Email-based authentication
    - Time-limited links
    - Like Laravel's magic links
    """
    __tablename__ = "magic_links"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    token = Column(String, unique=True)
    expires_at = Column(DateTime)
    used = Column(Boolean, default=False)

@router.post("/magic-link/request")
async def request_magic_link(
    email: EmailStr,
    db: AsyncSession = Depends(get_db)
):
    """Request magic link for passwordless login"""
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()

    if not user:
        # Don't reveal if email exists
        return {"message": "If email exists, magic link sent"}

    token = secrets.token_urlsafe(32)
    expires = datetime.now(timezone.utc) + timedelta(minutes=15)

    magic_link = MagicLink(
        user_id=user.id,
        token=token,
        expires_at=expires
    )
    db.add(magic_link)
    await db.commit()

    # TODO: Send email with magic link
    # await send_email(user.email, f"Login: {settings.FRONTEND_URL}/auth/magic/{token}")

    return {"message": "If email exists, magic link sent"}

@router.get("/magic-link/verify/{token}")
async def verify_magic_link(
    token: str,
    db: AsyncSession = Depends(get_db)
):
    """Verify magic link and login user"""
    result = await db.execute(
        select(MagicLink).where(
            MagicLink.token == token,
            MagicLink.used == False,
            MagicLink.expires_at > datetime.now(timezone.utc)
        )
    )
    magic_link = result.scalar_one_or_none()

    if not magic_link:
        raise HTTPException(400, "Invalid or expired magic link")

    # Mark as used
    magic_link.used = True
    await db.commit()

    # Get user
    result = await db.execute(select(User).where(User.id == magic_link.user_id))
    user = result.scalar_one()

    # Create token
    access_token = create_access_token(data={"sub": user.email})

    return {"access_token": access_token, "token_type": "bearer"}
```

## 📝 Exercises

### Exercise 1: Implement WebAuthn/FIDO2

Add passwordless authentication using WebAuthn:

```python
# pip install webauthn

# Implement biometric authentication
# Support security keys (YubiKey, etc.)
# Store credentials
```

### Exercise 2: Security Notifications

Send email notifications for security events:

```python
# Notify on:
# - New login from unknown device
# - Password changed
# - 2FA disabled
# - API key created
```

### Exercise 3: Advanced Rate Limiting

Implement sophisticated rate limiting:

```python
# Different limits per endpoint
# Per-user limits
# Progressive delays
# CAPTCHA after repeated failures
```

## 🧪 Testing Advanced Auth

```python
# tests/test_2fa.py
def test_2fa_setup():
    """Test 2FA setup flow"""
    # Login
    # Setup 2FA
    # Verify QR code generation
    # Verify backup codes

def test_2fa_login():
    """Test login with 2FA"""
    # Login with password + 2FA code
    # Test invalid codes
    # Test backup codes

# tests/test_oauth.py
def test_google_oauth_flow():
    """Test Google OAuth flow"""
    # Mock OAuth responses
    # Test account creation
    # Test account linking

# tests/test_api_keys.py
def test_api_key_authentication():
    """Test API key auth"""
    # Create API key
    # Use API key
    # Test expiration
    # Test revocation
```

## 💻 Complete Example

See `code-examples/chapter-11.5/` for complete implementations:

- **standalone/**: Advanced auth server
- **progressive/**: Task Manager v11.5 with advanced auth
- **snippets/**: Reusable auth patterns

## 🔗 Next Steps

**Next Chapter:** [Chapter 12: OpenAI Integration](12-openai-integration.md)

Start building AI-powered features with authentication!

## 📚 Further Reading

- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [WebAuthn Guide](https://webauthn.guide/)
- [OAuth 2.0 Security Best Practices](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- [TOTP RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238)
